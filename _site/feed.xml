<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-12-06T20:19:57-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Ayub’s Blog</title><subtitle>Ayub's blog. I write about programming, philosophy, and literature.</subtitle><author><name>Ayub Elwhishi</name><email>alloycipher@gmail.com</email></author><entry><title type="html">Mastery and Knowledge Mapping</title><link href="http://localhost:4000/my_knowledge_map/" rel="alternate" type="text/html" title="Mastery and Knowledge Mapping" /><published>2022-12-06T20:08:07-05:00</published><updated>2022-12-06T20:08:07-05:00</updated><id>http://localhost:4000/my_knowledge_map</id><content type="html" xml:base="http://localhost:4000/my_knowledge_map/"><![CDATA[<p>I follow a principle of humility with regards to what I know, denoted by a personal normative philosophy I hope in sharing fully one day. It takes an intuitionist perspective on</p>

<p>My knowledge map is a recent idea, brought on by the frustration of travelling through a field blind.</p>

<p>The <a href="/knowledge_map">unfinished demo</a> is a prototype I made using a simple <code class="language-plaintext highlighter-rouge">.yaml</code> file, which shows promise in building it painlessly, and showcasing it painlessly. I worried I’d have to figure it out myself, which I have no will to do, as I’d have to do my own code generation which is <em>always</em> fun.</p>]]></content><author><name>Ayub Elwhishi</name><email>alloycipher@gmail.com</email></author><summary type="html"><![CDATA[An overview of my academic knowledge map, making the data traversable to master a field in a meticulous and holistic fashion.]]></summary></entry><entry><title type="html">Plot Analysis</title><link href="http://localhost:4000/plot_analysis/" rel="alternate" type="text/html" title="Plot Analysis" /><published>2022-12-03T00:00:00-05:00</published><updated>2022-12-03T00:00:00-05:00</updated><id>http://localhost:4000/plot_analysis</id><content type="html" xml:base="http://localhost:4000/plot_analysis/"><![CDATA[<h2 id="intro">Intro</h2>

<p>Plot is the sequence of events that occurs in a story. There is a significant difference between story and plot, in that story represents plot in its own way. Plot always follows a series of cause and events. A -&gt; B that usually goes across a serial linear time. So A happens, then B happens, then C happens, etc.</p>

<p>A plot hole occurs when there is a break in the logic from A -&gt; B. For example, Steven goes to Germany in Chapter 1, but is in Belgium in Chapter 2 without explanation.</p>

<p>A plot is composed of multiple threads, which contain a line of actions that follow a thread-anchor. A thread-anchor ties the threads together. For example, in the hobbit, it was Bilbo Baggins that tied the thread together throughout the whole book I think, but in the Lord of the Rings, multiple threads follow multiple characters, with threads starting, merging, and ending based on the fates of those characters.</p>

<p>So the thread can follow a few things: 
	+ A single character
	+ A group of characters
	+ A setting</p>

<p>An object is not usually a thread-anchor, and when it is, it tends to act its own personified character, like the lyrics in Nas’s “I Gave You Power”</p>

<p>It leads to interesting situations, however. In the LOTR films, were Isildur’s scenes anchor to Isildur or the ring?</p>

<h2 id="observer-plot-threads">Observer Plot-Threads</h2>

<p>To solve this question, we further atomize the plot-thread to the observer thread. An observer thread is the plot-thread taken from the perspective of a single object/character.</p>

<p>So we take the perspective of Isildur’s scenes into two observers: the ring and Isildur. Each have their own stories, whereupon the ring’s thread extends far past Isildur’s thread, entering Gollum’s thread, and Bilbo’s thread, and so forth.</p>

<p>However, it also includes all the small things, like the horses, and the river, and the arrows, and anything mentioned or shown.</p>

<p>In a different scene, any cup that a character drank from has an observer thread. That would document the time it was given to them, picked up, drank from, and set aside. It technically dies there, but we can imagine it’s returned to the tavern keep where it’s cleaned. Any sword they used to fight, and so forth.</p>

<p>Multiple observer threads interact together to create a scene. The character drinks the cup, is composed of two observer threads interacting, such that from the cup’s observation: “The character drank from me.” and from the character’s observation: “I drink from the cup.”</p>

<p>Likewise, a location can also be an observer thread.</p>

<h3 id="plot-points">Plot Points</h3>

<p>A plot point happens when there is a change indicated towards the observer thread. If a character says something in a dialogue, that is a plot point. However, when a different character says something, the observer thread continues, but ceases any instance of action, until they do something like scratch their nose, or hiccup, or reply.</p>

<p>What happens between plot-points is often inferred, and it’s usually that between plot point A and plot point B that when something happens that breaks the assumption, it can become a surprise, or a plot hole in the case of an unintended surprise.</p>

<p>Here’s an example of subtle one:</p>

<p>1.A+C: A puts down C.
2.A: A puts up his hands.
3.A+C: A sips from C</p>

<p>It creates a small plot hole, since 3.A+C presumes that A is still holding the cup.</p>

<p>One could imagine there might be a bit of wiggle room, since the character can sip the cup without holding the cup if the imagined cup is topped out, which can be assumed if it’s right after the server has given it to the character, if not outright said. However, that is the domain of the story and not the plot. The plot <em>should</em> be as unassuming as possible.</p>

<p>So to correct the subtle plot hole, we’d have to fill in the blanks:</p>

<p>1.A+C: 	A puts down C.
2.A: 	A puts up hands.
3.A: 	A grabs C.
4.A+C:	A sips from C.</p>

<p>If something remains static, either in movement (a car) or in activity, or in such, then it’s inferred that it remains as such until ended.</p>

<h2 id="location-set-thread">Location (Set) Thread</h2>

<p>There is such a thing as a location thread, which is pretty much analagous to a mathematical set. We keep the name “element” for an observer inside a location.</p>

<p>A location becomes an element if no observer threads are within it and it’s referenced. A thing becomes a location if observer threads are within it and it’s referenced. (Spatially)</p>

<p>If I’m inside a tavern during a scene, then the tavern is a location. However, if I’m outside in the street, and I refer to the tavern, or if I’m going to the tavern, then the tavern is also a (sister) element.</p>

<p>A location is an observer thread, with the potential to hold observer threads within it.</p>

<h3 id="universal-location">Universal Location</h3>

<p>Location threads are rather pervasive. If a story takes place in a city, then the location anchors almost all the observer threads of the story. And from there, it grows out from country to continent, to world, etc.</p>

<p>This cascade is reduced to the “universal” thread. The universal thread is the the location thread that contains all occurences within the story.</p>

<h2 id="link-threads">Link Threads</h2>

<p>Def. For all x,y,z that belong to the set of observer threads, x is a link between y and z if x intersects both y and z threads. x != y, x != z.</p>

<p>Let’s look at this series of plot points (using location notation):</p>

<p>1: L(-A) 
2: L(+B)
3: L(+A,B)</p>

<p>Legend:</p>

<p>Point 1: Character A left location L.
Point 2: Character B entered location L.
Point 3: Character A entered location L.</p>

<p>In this previous example, L links A and B.</p>

<h2 id="starts-and-ends-of-threads">Starts and Ends of Threads</h2>

<p>The start and end of a thread relies on its location. A anchors location L1 and L2 if it crosses them. Let’s say that A goes from the tavern hall to the bedroom.</p>

<p>They are technically still contained within the tavern thread.</p>

<h2 id="narrative-thread">Narrative Thread</h2>

<p>We introduce then the concept of the narrative thread, which is the thread of whats written or shown in the story. The narrative thread is not necessary for plot points to occur, as these plot points occur “off screen”, but the narrative thread is necessary for a plot-point <em>to exist</em> for the reader.</p>

<p>So the narrative thread is quite unique in being alive. It transcends the universal location of the plotline in its ability to explain things that exist and don’t exist.</p>

<p>To understand why, the narrative thread is the thread that constructs the plotline. While things can happen before the official narrative, it occurs during exposition.</p>

<p>The start and end of an observer thread is as the narrative thread moves locations.</p>

<p>If the narrative thread moves from L1 to L2, anything that hasn’t moved from L1 to L2 terminates there, and starts again when they appear in a new location, or they appear in the new thread.</p>

<hr />

<h1 id="applying-the-theory">Applying the Theory</h1>

<p>It’s mostly a method of analysis and construction for now, but I want to use it to see why plots of certain stories are good.</p>

<h2 id="list-of-masterpieces-in-plot">List of Masterpieces in Plot</h2>

<p><strong>Film</strong></p>

<ul>
  <li>The Truman Show</li>
  <li>Shawshank Redemption</li>
</ul>]]></content><author><name>Ayub Elwhishi</name><email>alloycipher@gmail.com</email></author><summary type="html"><![CDATA[Intro]]></summary></entry><entry><title type="html">Quine, On What There Is</title><link href="http://localhost:4000/quine_on_what/" rel="alternate" type="text/html" title="Quine, On What There Is" /><published>2022-12-03T00:00:00-05:00</published><updated>2022-12-03T00:00:00-05:00</updated><id>http://localhost:4000/quine_on_what</id><content type="html" xml:base="http://localhost:4000/quine_on_what/"><![CDATA[<h2 id="summarization">Summarization</h2>

<details>
  <summary> Definitions </summary>

  <dl>
    <dt>Bound Variable</dt>
    <dd>A variable that is bound to a specific value or explicit range of values.</dd>
    <dt>Ontology</dt>
    <dd>A collection of what one takes to exist, both in real and hypothetical contexts.</dd>
  </dl>

</details>

<p>Quine considers the ontological problem to be the question: What is there?</p>

<p>The naive answer is to say that all that there is, is everything. However Quine’s rebutes by saying that this is a tautology.</p>

<details class="pn_note">
  <summary> Personal Note </summary>

  <p>‘What is there?’ is a bit harder to understand, so ‘What exists?’ is what he literally means. So to answer ‘what exists is all that exists’ is the tautology.</p>

</details>

<h3 id="something-exists-by-virtue-of-reference">Something exists by virtue of reference</h3>

<p>He moves on to discuss disagreements in ontology. In a hypothetical, McX believes something exists, and Quine believes something doesn’t. However, when Quene says that McX believes in something that doesn’t exist, then it must exist for it <em>not to exist</em>. i.e. If I say something doesn’t exist, it exists by virtue of it being referenced.</p>

<p>That’s the gist, however I want to note this quote:</p>

<blockquote>
  <p>When I try to formulate our difference of opinion, on the other hand, I seem to be in a predicament. I cannot admit that there are some things which McX countenances and I do not, for in admitting that there are such things I should be contradicting my own rejection of them</p>
</blockquote>

<p>He words this in an interesting way though, he says that the Narrator cannot admit that <em>McX believes in something that the Narrator himself doesn’t believe in</em>, as doing so basically admits that McX’s fantasy exists. He takes a third person approach when wording it out.</p>

<details class="pn_note">
  <summary> Personal Note </summary>

  <p>Is it different? I ask this because I’m wondering if saying “Admitting McX believes something exists means that it must exist”, is different from saying “Something exists if we say it doesn’t, because we refer to it.” If it is, then it’s clearly erroneous because admitting McX believes something, doesn’t mean he references that something, it references his belief in relation to something.</p>

</details>

<p>He goes on later to basically say “Non-being must in some sense be, otherwise what is it that there is not?”, which is going back to what I explained before.</p>

<p>He calls this idea of something existing by virtue of being referenced as “<abbr class="pn_ann"><button class="mark">Plato’s beard</button><button class="dfn"><span>Because it dulls the blade of Occam’s razor.</span></button></abbr>”</p>

<p>Quine also goes onto flesh out the example by saying that McX believes that Pegasus exists. However, it should be noted that Quine says McX doesn’t believe it literally exists in the real world, but by virtue of it being referenced, it must exist “somewhere”. McX says this “somewhere” is the mind.</p>

<p>Quine uses this opportunity to attack the position, by saying that McX confuses the idea of Pegasus with the entity of Pegasus. When we say Pegasus doesn’t exist, we don’t refer to its representation in our minds, but the entity it refers to.</p>

<p>He proves the difference by saying the Parthenon exists, but it exists seperate from its idea, so when we refer to the Parthenon’s existence, it’s of the Parthenon itself, and not our idea of it.</p>

<details class="pn_note">
  <summary> Personal Note </summary>

  <p>Interesting parallels between this and a memory pointer/reference in computation</p>

  <hr />

  <p>There is some trouble here, as McX is saying that the entity must exist by virtue of reference, yet Quine saying that it’s incorrect because there’s a distinction between reference and entity. This doesn’t make sense, since it doesn’t talk about the relation between reference and the entity’s existence. If he’s implying that they are seperate, as in reference doesn’t determine the existence of an entity, then it still doesn’t attack McX’s belief that reference determines existence, as it only iterates the negation.</p>

</details>

<h3 id="pegasus-exists-yet-has-not-been-actualized">Pegasus exists yet has not been actualized.</h3>

<p>Quine moves onto the second argument for stating Pegasus exists, this time coming from Wyman.</p>

<p>Wyman says that Pegasus exists but it’s not actualized. He specifies it further by saying it doesn’t have the <em>special attribute</em> of actuality in the same way the Parthenon is not red.</p>

<p>Quine says that the problem with this is that Wyman has only redefined actuality with existence, shifting the problem there.</p>

<p>Quine provides a commonsense definition of existence, that when refering to something spatio-temporal, such as Pegasus, then <em>exists</em> connotates its existence in our spatio-temporal realm. He makes a careful note that it <em>exists</em> is not inherently spatio-temporal, because if we say that the cube root of 27 exists, then it remains in a non spatio-temporal context.</p>

<p>There’s a footnote where he brings up the idea that a spatio-temporal kind of existence is the only relevant one since it’s the only one that can be naturally checked, but he refutes it by example: “The ratio of the number of centaurs to the number of unicorns”, where spatio-temporal nature has to be checked to prove whether the non spatio-temporal entity exists.</p>

<p>Wyman accepts that Pegasus doesn’t exist, but says that Pegasus still <em>is</em>, in that it persists.</p>

<p>Quine moves on to attack the conclusions of Wyman’s belief.</p>

<p>The first is that two <em>possible entites</em> conflict heavily between each other (possible fat man in a door way, and a possible bald man in the doorway).</p>

<p>In such a case, he offers that a Fregean or some form of modal logical treatment can be used to mediate the conflicts, but modalities are used on a statement as a whole, rather than with the idea of possible entities. And if it goes to include it, it becomes redundant to use.</p>

<p>He says that all this seems a return to McX’s belief, in that it must exist by reference, which he’s shown is erroneous.</p>

<p>The second is that we can give an instance of something that simply can’t exist, for example a “round square cupola on Berkeley College”, which is self-contradictory (round square).</p>

<p>Wyman can reply that the round square cupola is meaningless, since it makes no sense.</p>

<p>Quine then argues for the meaning of contradictions. The meaninglessness of contradictions, Quine says, <abbr class="pn_ann"><button class="mark">makes it impossible to devise an effective test of what is meaningful and what is not</button><button class="dfn"> He references <a href="/scripture/church_a_note">Alonzo Church’s “A note on the Entscheidungsproblem”</a> as proof.</button></abbr>. For example, whether a string of letters makes sense or not.</p>

<h3 id="bringing-in-russell">Bringing in Russell</h3>

<p>Quine moves on to deal directly with Plato’s beard, by bringing up Russell’s theory of “singular descriptions”, where he argues how we can use names without the existence of the entities that are named.</p>

<p>The names that Russell’s theory applies to are <em>complex descriptive names</em>, like “the author of Waverly” and “the present King of France”. Russell breaks these sentences down into phrase fragments.</p>

<p>“The author of Waverly was a poet.” for example is explained as:</p>

<ul>
  <li>Something wrote waverly</li>
  <li>They were a poet</li>
  <li>Nothing else wrote waverly</li>
</ul>

<p>The seeming name (“The author of Waverly”) is called an <abbr class="pn_ann"><button class="mark"><em>incomplete symbol</em></button><button class="dfn">“Term used by Russell to describe definite descriptions and other expressions which have the feature that they cannot be defined in isolation, but only by means of giving an analysis of any entire sentence in which they are embedded.” - <a href="https://www.oxfordreference.com/view/10.1093/oi/authority.20110803100000539">Oxford reference</a> </button></abbr>, where you can’t analyze the expression by itself. The phrase as a whole (“The author of Waverly was a poet”, which is the context of the name) is meaningful regardless, whether true or false.</p>

<details class="pn_note">
  <summary> Incomplete Symbol </summary>

  <p>You can read Russell’s <a href="https://users.drew.edu/~jlenz/br-logical-atomism6.html">work on descriptive names</a> where he defines the incomplete symbol better than I can do.</p>

</details>

<p>Both McX and Wyman say that “the author of Waverly” requires objective reference in order to be meaningful at all.</p>

<p>But when looking at the deconstructed sentence (Something wrote Waverly. They were a poet. Nothing else wrote Waverly), the burden of objective reference is placed on <em>bound variables</em>, which are variables of quantification like “something”, “nothing”, “everything”. They aren’t names for the author of Waverly, they’re general names of entities that hold ambiguity.</p>

<p>And while these variables are meaningless, they no way presuppose that there is an author of Waverly.</p>

<p>So when we say that “There is the author of Waverly”, it means “Something wrote Waverly. Nothing else wrote Waverley.”</p>

<p>And when we say that “The author of Waverly is not”, we mean “Either everything didn’t write Waverly, or two or more things wrote Waverly”. Note how it does not contain any expression referencing the author of Waverley.</p>

<p>Thus, if a statement of being and non-being of an entity is analyzed by Russell’s method, it shows that it dosen’t contain any expression which references the entity. Thus the meaning of the statemetn doesn’t need to presuppose the existence of an entity.</p>

<h3 id="pegasus-the-word">Pegasus The Word</h3>

<p>Quine then moves on to discuss the word aspect, since Russell’s talking about complex descriptive names. Pegasus can be turned into a description by placing it into a statement. For example “A winged horse that was caputred by Bellerophon”, can have “a winged horse” replaced with “Pegasus”.</p>

<p>So to see if a single word name can be analyzed under Russell’s theory of description, we have simply to replace it.</p>

<p>However, if Pegasus is obscure or basic such that no simple translation into a descriptive phrase is obvious, then we can still do it. This is done by hypothesis in appealing to the irreducible attribute of “being Pegasus”, which he calls “is-Pegasus” or “pegasizes”, which are verbs. Pegasus as a noun can then be treated as a derivative and identified with the description: “the thing that is-Pegasus”, “the thing that pegasizes”</p>

<p>Thus, he concludes, that referencing something doesn’t mean it exists.</p>

<h3 id="meaning-vs-naming">Meaning vs Naming</h3>

<p>He moves on from Russell in distinguishing between meaning and naming something.</p>

<p>He uses Frege’s example, by saying that the Evening Star and the Morning Star both name the same thing but they don’t <em>mean</em> the same thing. The meanings of the names thus must be different from the entity.</p>

<p>McX confused the meaning of the named object Pegasus, with the entity ‘Pegasus’, saying that Pegasus must exist in order for the word to have meaning.</p>

<p>He asks what is a meaning, then? This is a moot point, but he doesn’t explain why. He humours the question by saying that we can say that meanings are ideas in the mind, thus Pegasus which was confused for a meaning, ends up as an idea in the mind still.</p>

<p><em>(I had trouble here with what he meant between meaning and naming)</em></p>

<h3 id="universals">Universals</h3>

<p>Quine then goes to talk about the ontological problem of universals: Are there such things as attributes, relations, classes, numbers, and functions?</p>

<p>McX says there are. Red house, red rose. Both exist, both share the attribute of redness.</p>

<blockquote>
  <p>One’s ontology is basic to the conceptual scheme by which he interprets all experiences, even the most commonplace ones. Judged within some particular conceptual scheme - and how else is judgement possible?</p>
</blockquote>

<p>He says in a different conceptual scheme, McX can be made wrong. For example, by saying that there are red houses and red roses, but they share nothing in common. “Houses” and “roses” are of individual entitites, and “red” is an individual entity of “red houses” and “red roses”. And in the same way there is no entity named “redness”, there is no entity named “househood”, or “rosehood”</p>

<details class="pn_note">
  <summary> Personal Note </summary>

  <p>This is much like a DNA in a cell, vs shared state in concept. I take it that there is no such thing as redhood without an observer, but recognition of the commonality between them coalescing into a single idea in the mind does exist.</p>

  <p>I used to think that there are two kinds of shared state: emergent between individual objects such as DNA in a cell, and one shared between each other, such as in a server/client relationship, or global state in a program. In hindsight, both have their structural uses. The intelligent organism is made up of a centralized shared state (the brain) and the distributed shared state (the cell).</p>

  <p>The structural benefits of each are obvious, the centralized shared state can regulate who and what gets information in a singular manner, and how it interacts with it, while the cell is individual to each. DNA couldn’t work in a centralized state because each cell needs to interpret it its own way. Likewise, the coherent whole of an organism couldn’t work with a distributed shared state, as all cells need to be orchestrated in a way that is above individual.</p>

</details>

<p>McX could’ve argued that referring to something red means that they exist, but Quine already handled that belief.</p>

<p>McX says something different then, that ‘being red’ has meaning, and that the meanings, whether named or not, are universals.</p>

<p>Quine counters it by refusing to admit meanings.</p>

<p>People talk about meanings in two ways: the having of meanings (<em>significance</em> and <em>insignificance</em>), and the sameness of a meaning (<em>synonomy</em> and <em>heteronymy</em>).</p>

<p>Quine provides a nice summary of his paper up till now, which I ought to use for my own summary:</p>

<ul>
  <li>He has argued that we can use singular terms signifincantly in sentences without presupposing the entity’s existence of those terms.</li>
  <li>He has argued that we can use general terms without conceding them to be names of abstract entities.</li>
  <li>He has argued further that we can view utterances as significant and synonymous/heteronymous without accepting a realm of entities called meaning.</li>
</ul>

<p>McX must ask does nothing we say commit to the assumption of universals or entieis which we may find unwelcome?</p>

<p>The only way we can tell the existence of an attribute is to say: there is <em>something</em> which red houses and roses have in common. Or there is <em>something</em> which is a prime number larger than a million. But it’s the only way we can refer to universals.</p>

<details class="pn_note">
  <summary> Personal Note </summary>

  <p>The topic of emergence is somewhere here with regards to the existence of universals.</p>

</details>

<p>Quine says names are altogether immaterial to the ontological issue, as shown.</p>

<p>To be assumed as an entity is to be reckoned as the value of a variable. Linguistically, it translates to being in the range of reference of a pronoun.</p>

<details class="pn_note">
  <summary> Personal Note </summary>

  <p>What of the implications of ideas on reality? A planned bridge does not exist, except as its idea, but when we build it, it then does exist. But had it not exist as an idea before, its identity simply be “actualized” as said before. It brings into question the temporal nature of existence as well, and determinism. If we believed in eternalism, that everything does exist as it does throughout time, does not it lend to the “unactualized” theory of existence?</p>

  <p>I don’t think it has to do with the idea existing, per se, but it has to do with the mind’s ability to mimic reality, such that the idea of the planned bridge can interplay between “existences”. To us it has existence as visualizations, mock-ups, plans, etc. When we construct it, then the bridge carries the identity of the idea before. The variable becomes “bound” to reality in Quine’s terms, but before it, the name remained bound to its non-existent form (its abstract form), which exists only in our minds.</p>

  <p>McX mistakes Pegasus for the entity existing outside of himself, when it is an entity existing within himself or the noosphere (if we accept other minds). A test can be made by direction. If Pegasus exists by perception (we apply real perception to pegasus) then pegasus exists. But if pegasus has to be created to exist, then it remains within ourselves, but then testimony begins to become a problem.</p>

</details>

<h3 id="overview-of-positions">Overview of Positions</h3>

<p>Quine clarifies the positions regarding universals in the history of philsophy.</p>

<p>Medieval viewpoints: <strong>realism</strong>, <em>conceptualism</em>, and <em>nominalism</em></p>

<p>Modern Phil. of math viewpoints: <em>Logicism</em>, <em>intuitionism</em>, and <em>formalism</em>.</p>

<p>These aren’t necessarily definitions of the factions, rather the viewpoints that they hold on universals.</p>

<p><em>Realism</em>: The Platonic doctrine that universals/abstract entities have existences independently of the mind. The mind may discover them but cannot create them.</p>

<p><em>Logicism</em>: Allows bound variables to refer to anything, whether it’s known or not, and specifiable or not.</p>

<p><em>Conceptualism</em>: There are universals but they are mind-made entities.</p>

<p><em>Intuitionism</em>: Bound variables refer to abstract entities with a determined formation, such that you’re discovering rather than creating. Sort of like how you discover a piece of technology rather than create it like a book or a painting. The piece of technology could’ve been found on its own by someone else, and have it be the same overall design, because it would be built for a specific purpose using shared intuition.</p>

<p><em>Formalism</em>: Mathematics is a play of insginificant notions, even if it can be utilized. <em>Significance</em> is used in the literal linguistic sense.</p>

<p><em>Nominalists</em>: reject the existence of abstract entities, even with ideas.</p>

<h3 id="ontologies">Ontologies</h3>

<p>Quine asks for this section: how do we mediate opposing ontologies? Ontologies, as he says before, provides the “basic conceptual scheme by which [we] interpret all experiences.”</p>

<details class="pn_note">
  <summary> Personal Note </summary>

  <p>Quine’s use of the word ontology isn’t made very clear, and from my interpretation he means by what we regard exists, as noted by the quote:</p>

  <blockquote>
    <p>We commit ourselves to an ontology containing numbers when we say there are prime numbers larger a million.</p>
  </blockquote>

  <p>I also want to include that what he means by ontology is also <strong>how</strong> we determine what exists. i.e. things exist by virtue of reference, is a type of ontology. It works out because determining how something exists denotes a set of things that exist within an ontology anyways.</p>

</details>]]></content><author><name>Ayub Elwhishi</name><email>alloycipher@gmail.com</email></author><summary type="html"><![CDATA[Summarization]]></summary></entry><entry><title type="html">My Progamming Language</title><link href="http://localhost:4000/programming_language/" rel="alternate" type="text/html" title="My Progamming Language" /><published>2022-12-02T00:00:00-05:00</published><updated>2022-12-02T00:00:00-05:00</updated><id>http://localhost:4000/programming_language</id><content type="html" xml:base="http://localhost:4000/programming_language/"><![CDATA[<p>My writing on “reigning” a computer comes with a great question: where on earth do I start? The issue comes by the chasm between application and theory, and the many bridges crossing it.</p>

<p>After a bit of soul searching, I thought the funnest way to start is by writing my own programming language. I can use the language to create libraries in that language, applying to whatever domain of computer science I can think of. So if I’m learning data structures and algorithms, I’d find use writing for my language there.</p>

<p>It’s all just assembly in the end.</p>

<p>But I never do good with blank slates, for as soon as I start to imagine, I start climbing mountains. It doesn’t help that I’m reading on ontology now, and so the thought of creating a programming language has me enter into questions about meaning, entities, causation, and so on.</p>

<p>It’s become overwhelming how similar yet different everything is: Name, variable, symbol, pointer, reference, object. I don’t know where to start and where to begin.</p>

<p>I also asked myself, is code, data, and is data, code? It feels a perverse coupling. It’s like saying time is a substance. But it is, isn’t it? When we look at a function, we can create a derivative from, showing substantive representation of its change. Likewise, if we say x is position, and y is time, then isn’t y itself a substance as much as a position is? But no, position is an attribute.</p>

<p>The functions of x and y can’t be entities, but attributes rather. The height of something over time, the height of something with respect to its distance from something. A relation is between the attributes of an entity. So time another attribute?</p>

<p>My head hurts. I’ll leave my own philosophizing for later, as I respect the field and I want to read more to catch up on its discussion. I don’t want to corner myself into more preconceptions than I already have when approaching it.</p>

<p>But that doesn’t help me figure out my programming language. I’m granted time, for now, to simply take in knowledge on programming language. I’ll want to go back to linguistics and learn some syntax. I’ll also want to spend some time with interesting languages like Lisp and what not. It gives me opportunity to imagine the perfect language I could try to implement.</p>

<h2 id="type-system">Type System</h2>

<p>I dislike the idea of native type systems, and I want to go to as basic as I can get it. In assembly, you are (typically) thrust upon three inherent types of data to which operations are provided for: integer, logic (bitwise), and floating point.</p>

<p>What I mean by that is: you have integer operations (in binary representation), you have bitwise operations (logical operations), and you have floating point operations (<code class="language-plaintext highlighter-rouge">fadd</code>). I don’t know why people keep answering that assembly doesn’t have native types. If it has operations done under an assumed representation, it has native data types.</p>

<p>I think my confusion comes from the fact that I got used to implicit variable types in langauges like Python and JS, so I don’t see type restriction inherent in typing systems anymore. Regardless, anyone who uses assembly will recognize that someone using integer operations on a floating point value will muck up their numbers, so I declare that types are implicit in contemporary assembly, and the only pure non-typed instruction set would be one that purely uses bitwise operations.</p>

<p>The addition of the other two types creates a bit of efficiency and complexity. I’d love to write in pure logic but I’d be a bit insane to implement addition using bitwise operations when I can just use an add instruction natively. It’s far more efficient too, since bitwise operations work on the whole byte.</p>

<p>Same goes with floating point arithmetic. So it seems you need to use those data types in assembly.</p>

<p>However, <em>my language</em> doesn’t need to. Individual bit operations provides the basic form of all circuit operations. The issue would be to create a compiler that can recognize bitwise operations as other forms of instructions, and optimize for it. It shouldn’t be too difficult, I hope, as arithmetic and other operations are implemented using logic gates, there must be some syntactic way to recognize it.</p>

<p>It seems insane, but the idea is to build up other types using the basic bit type.</p>

<h2 id="lisp-like-macro-system">Lisp-like Macro System</h2>

<p>I’m inspired by metaprogramming to create an ability to expand the syntax, which explains why there’s only one native type. The user is allowed to define new aspects of the grammar, and employ new operations.</p>

<p>A problem would be representing the differences between operations and data. In lisp, it’s fairly easy since it’s positional. I dislike lisp’s syntax, however, because it’s a bit counter intuitive and prefer a more natural syntax. Python probably has the most intuitive syntax, but personally C itself is fairly easy to read because it’s terse.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int x = 42;
int y = x + 42;

let int x equal 42
let int y equal x + 42
</code></pre></div></div>

<p>I can go like javascript and lisp and just have an <code class="language-plaintext highlighter-rouge">eval</code> type statement that represents the code, and provide a way to represent it differently, but I’m unsure of how it’d work. My gripe is the syntax of it. Let’s break it down a bit more.</p>

<p>You’d have to have the ability to modify the automaton, essentially.</p>

<p>But it should be fairly simple, when you think of it. If we go to C syntax, every line is essentially a statement.</p>

<p>so</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int x = 42; // is a statement
</code></pre></div></div>

<p>Lets say we create a construct which defines the grammar for a statement. So lets say I want an operator which adds all following values together.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>macro: 
type var [:=] value ...; { 
	var = value + ...;
}
</code></pre></div></div>

<p>Which means that <code class="language-plaintext highlighter-rouge">int_8 x := 34 14 15 19;</code>. In the definition <code class="language-plaintext highlighter-rouge">type</code> is the signifier for the type variable, so the user can lay down what type they have, the var represents the symbol of the varable. <code class="language-plaintext highlighter-rouge">[:=]</code> defines the operator’s symbols, and <code class="language-plaintext highlighter-rouge">value</code> is just the name for the base type, which I guess can be inherited by other types? The definition follows on previous syntactical rules and <code class="language-plaintext highlighter-rouge">...</code> is just the construct for rolling out something I guess.</p>

<p>Let me make an addition statement as well.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>macro:
(var op[+] var) {
	...bitwise operation for it
}	
</code></pre></div></div>

<p>I guess this is an enclosed expression, so it can be embedded into statements (<code class="language-plaintext highlighter-rouge">x = y + z</code>). I guess it goes on a right to left operand as well. How does it evaluate brackets? Bracket notation will just have to be meta, so it will always evaluate that expression first.</p>

<p>I’ll want to go into syntax a bit on this for sure. It’s clear some form of regular expression is used to define it. To make something evaluable at runtime:</p>

<h2 id="concurrency--temporal-logic">Concurrency &amp; Temporal Logic</h2>

<p>Serial programming is archaic, and I want to create a language that is more interesting than a -&gt; b -&gt; c.</p>

<p>My experience with concurrent programming isn’t multi-threaded. It’s javascript async functions, so I probably want to go exploring threads before I do anything, but perhaps my ignorance on the topic will give me more interesting ideas so I’ll seek to exploit that when I can.</p>

<p>JS async functions are fun to use, but they’re not multi-threaded proper, and you can’t manipulate the ins and outs of em much.</p>

<p>I thought to use a different theory <a href="">I wrote</a> with regards to plot-lines in literary analysis. It’s hard to explain fully, but as a person reads a book, they construct multiple plotlines which are (in the theory) observed from the different entities within the story. Entities includes anything, from inanimate objects (Ring of Power) to characters (Bilbo).</p>

<p>It’s technically single processed, as it’s a single reader processing the book, but if we can add multiple books in the same <em>world</em>, which allow multiple readers to each interact and construct the world individually. These readers can then communicate with one another what happens, but that’s where the analogy dies.</p>

<p>My idea is to have scopes (think set theory, or boxes) where entities in those scopes are limited to those scopes, both outside, from an internal scope. Entities can exit or enter a scope. They all exist inside a general scope.</p>

<p>The beautiful thing about it is the interactions between scopes. Scopes have a series of instructions that they run through. I should probably write what I mean right now to make things make sense.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int x = 5;  

scope A (int count) { // define the scope or function really  
	while (p &lt; count) {
		int p = 0;
		point pt_1;
	}
	
	if (p &lt; x) wait; // error, because x doesn't exist, even when nested

	if (p == 4) wait;
	
	die; // default if unspecified, kills the scope after it finishes executing
}

A(x); // execute scope

operation add -&gt; A {  // define operation in A's context, p is kept 
	int p = (int p);
	if (p &lt; 5) p++;
	wait;
}

send add and execute; // sends and executes right away. If the scope is in the middle of the while loop, then it will execute then.
	// if it can't find anything (i.e. it can't find p's definition) then it returns an error. 
send add at pt_1; // sends the operation at pt_1 and executes, if it finds it;
send add and wait for wait; // sends and waits for a wait. When it gets to the wait, it executes.
send add and wait for definition; // sends and if any anything is undefined, then it waits until it is defined.

</code></pre></div></div>

<p>It seems bad coding practice to be able to reference and modify things inside the scope, but my purpose is to make a natural and interesting language, not a clean language. The idea is that you send someone into a room, and they do things for you while you handle your own stuff. You should know what’s in the room before you send someone to modify the stuff inside it.</p>

<p>When the scope dies, it’s released from memory and no longer persists.</p>

<p>Can we expand this?</p>

<p>What if we have things that connect between rooms? Like a light switch in one room, and a light bulb in another. Thus, it involves shared state.</p>

<p>This is very similar to the actor model of concurrency, but in a more meta-programming type of way, since we’re literally modifying the instructions. We also have the idea of rooms rather than only actors, where actors can go into a room, do stuff within the room, leave. The issue is that actors can’t usually persist outside their room, which me be something we want to do. So we can send an object somewhere, with a script of action?</p>

<p>I think one way to solve the differences in scope is the have a sort of interface between rooms. But at what point am I just recreating objects? The interface would rather be something like entering a scope. To see how far I can go modifying a scope, I’ll want to see what threads can really do.</p>

<h3 id="temporal-logic">Temporal Logic</h3>

<p>The issue with coding temporal logic in compsci is reliability, even if going off the computer’s dimension of time (clock cycles).</p>

<p>Time would have to be simulated by the language itself.</p>

<h3 id="having-fun-with-this">Having Fun with This</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while (true) {
	scope A (void) {
		while (true) {
			;
		}
	}
	A();
}
</code></pre></div></div>

<p>This prints out an endless number of persistent scopes.</p>

<h2 id="objects--ontology">Objects &amp; Ontology</h2>

<p>Objects are a very metaphysical (if not semantic) construct, which I think added to their popularity. It’s a natural way of thinking, seeing something smaller, and building it up. So why haven’t objects really leant themselves to artificial intelligence?</p>

<h2 id="probability--modality">Probability &amp; Modality</h2>

<p>Probability is always an interesting</p>

<h2 id="self-modifying">Self-Modifying</h2>

<p>I want to add the ability to self-modify.</p>

<p>It’d have to be additive rather than truly self-modifying. i.e. when a new definition is made, it creates new instructions in memory and apply the variable to it rather than rewrite the current ones.</p>

<h2 id="graph-inspired-constructions">Graph Inspired Constructions?</h2>

<p>Graphs have always seemed to be the most intuitive.</p>

<h2 id="ontology-and-merology">Ontology and Merology</h2>

<p>Merology is the study of parts and wholes.</p>]]></content><author><name>Ayub Elwhishi</name><email>alloycipher@gmail.com</email></author><summary type="html"><![CDATA[My writing on “reigning” a computer comes with a great question: where on earth do I start? The issue comes by the chasm between application and theory, and the many bridges crossing it.]]></summary></entry><entry><title type="html">Searle</title><link href="http://localhost:4000/searle/" rel="alternate" type="text/html" title="Searle" /><published>2022-12-01T00:00:00-05:00</published><updated>2022-12-01T00:00:00-05:00</updated><id>http://localhost:4000/searle</id><content type="html" xml:base="http://localhost:4000/searle/"><![CDATA[<h1 id="my-analysis-of-searles-chinese-room">My Analysis of Searle’s Chinese Room</h1>

<p>Searle’s Chinese room is an uncomfortable thought experiment to computationalists, and one I think gets unfairly brushed aside by them. The arguments often end away with saying “the system” is the consciousness, or that it’s flawed in some way. Searle does a well enough job of replying to each of them.</p>

<p>They tend to overcomplicate the beautiful simplicity of the thought experiment. The idea is not that the homunculus, or the person inside the room doing the calculations is conscious, the problem is that he <em>he doesn’t understand</em> what he’s doing when he’s calculating. It has nothing to with consciousness, it has everything to do with semantics and meaning.</p>

<p>Its implications being that a CPU executing calculations alone is not enough to explain understanding.</p>

<p>It’s pretty cut and dry for me, and it stands as a useful test for determining whether an artificial intelligence understands, or it’s just hardware doing calculations. It’s far more rigurous and contemporary than a behaviourist test, like the turing test.</p>

<p>I think the issue is that for computationalists, it gives some misplaced fear that it challenges their theory of mind. Connectionism, while not close to explaining how the brain works as they like it to be (take it we’re still deciding how neurons even code information), has proved terribly effective in illustrating some measure of intelligence.</p>

<h2 id="the-trouble-of-rationality-and-problem-solving">The Trouble of Rationality and Problem-solving</h2>

<p>Hume’s is-ought problem. We can problem solve, but it doesn’t provide us a reason to problem solve. i.e. problem solving alone is ambiguous, and holds no candle to consciousness nor understanding problem solving is ambiguous, and our inability to solve a problem does not detract from our ability to eventually understand.</p>

<p>Searle points out rather preccientally that a computer which solves a problem through syntax alone cannot understand what they’re doing.</p>

<blockquote>
  <p>Does problem-solving alone solve 
Does our intuition require self-perception, and will?</p>
</blockquote>

<h2 id="parallelization-a-false-messiah">Parallelization: A (false) messiah?</h2>]]></content><author><name>Ayub Elwhishi</name><email>alloycipher@gmail.com</email></author><summary type="html"><![CDATA[My Analysis of Searle’s Chinese Room]]></summary></entry><entry><title type="html">Project Ideas</title><link href="http://localhost:4000/project-ideas/" rel="alternate" type="text/html" title="Project Ideas" /><published>2022-10-20T00:00:00-04:00</published><updated>2022-10-20T00:00:00-04:00</updated><id>http://localhost:4000/project-ideas</id><content type="html" xml:base="http://localhost:4000/project-ideas/"><![CDATA[<h2 id="0-introduction">0. Introduction</h2>

<p>NOTE: (This page has a lot of perspective shift as I’m converting this to first person perspective for a more passive voice; just a disclaimer)</p>

<p>A problem I frequently see with programming project ideas are the lack of useful ideas. Things you would actually want to make that would feel useful both to me and others, so I’ve made a list here of things I think would be useful.</p>

<p>This has FOSS in mind, as many of these ideas are implemented through proprietary software, but not yet through FOSS projects. It’s an indicator of difficulty though, so beware.</p>

<h2 id="1-uml--hard-">1. UML ( HARD )</h2>

<p>UML (Unified Modelling Language) is a graphical language used to describe software models, aimed primarily for systems architects, engineers, and so on to describe large software systems.</p>

<p>It’s overkill for smaller projects, but a useful map/blueprint for larger ones where you really need the organization and understanding, especially in a team.</p>

<p>Because it’s fairly esoteric to programmers who think they’re too cool for school, there isn’t much stuff for it. At least not enough that a useful project can’t be made.</p>

<p>Most of this probably requires a fair bit of knowledge on compiling. <a href="https://suif.stanford.edu/dragonbook/">The Dragon Book</a> is what I think I’d need to figure most of this out. I’ve read a little on it before, enough to create my own parser, but I’d have to read it again more completely.</p>

<h3 id="textual-uml-in-cc">Textual UML in C/C++</h3>

<p>There are already textual representations of UML available, but they’re either proprietary, made in Java, or are web apps.</p>

<p>I just want a simple <code class="language-plaintext highlighter-rouge">tex</code>-like program that can take textual UML, and convert it into a UML file (XMI file, XML format)</p>

<p>What is textual UML? It’s a textual representation of UML, that gets turned into the normal graphical UML. It’d sort of be like what Verilog is for standard circuits diagrams.</p>

<p>I don’t have to create a new one, as there are various forms. <a href="https://plantuml.com/">PlantUML</a> is free, but it’s one of the Java ones I talked about. <a href="http://txtuml.inf.elte.hu/wiki/doku.php">txtUML</a> is also another one that uses Java, with documentation on the language.</p>

<p>Java is cumbersome to download, and I should be able to run a simple binary for this type of app.</p>

<p>I want to use C for it, since it’d make it intepreter independant. There’s already <a href="https://github.com/skanaar/nomnoml">one for Javascript</a>, but not one in Python as I can find it.</p>

<h3 id="code-to-uml--uml-to-code-compiling">Code to UML / UML to Code compiling</h3>

<p>This one’s more exciting, it takes software architecture defined in UML and converts it to actual source code, or vice-versa.</p>

<p>There’s a lot of this already done for python, because of course, but you can do a lot yourself for your own preferred language.</p>

<h2 id="2-document-viewingediting-on-the-web">2. Document Viewing/Editing on the Web</h2>

<p>You’d expect widespread support for this as well, but FOSS libraries are really lacking. You’ll find plenty of proprietary document readers, but no (good) open source ones.</p>

<p>The lack of support indicates that this is a very tedious problem to solve, enough that people won’t do it for free, so I’d focus on a specific doc type with good libraries already behind it rather than create an all in one document reader.</p>

<h3 id="a-worthwhile-pdf-annotation-library-for-javascript-and-react--medium">A worthwhile PDF Annotation Library for Javascript and React  (MEDIUM)</h3>

<p>This one had me annoyed when I was researching possibilities for Monalect. You’d think someone somewhere would’ve programmed a worthwhile FOSS PDF annotation+reader, but no good one exists.</p>

<p>Javascript spoiled me enough, it seems. This one would be really useful to everyone if made.</p>

<p>Features you should include:</p>

<ul>
  <li>Highlighting</li>
  <li>Notemaking</li>
  <li>Saving the annotations to the annotation layer of the PDF</li>
</ul>

<p>You can build off of PDF.js’s viewer because it’s technically under a free license, but they request you don’t w/o significant modification, and they’re saints for dealing with the PDF spec so I’d respect their wishes.</p>

<h3 id="create-a-performant-scrollable-pdf-viewer-for-javascript-and-react-medium">Create a performant scrollable PDF viewer for Javascript and React (MEDIUM)</h3>

<p>Web-workers, async, and lazy loading w/ pdf.js.</p>

<p>It should be for everyone to use. Again, pdf.js doesn’t like their viewer being used for some reason. Or rather, they don’t like it being used unmodified or reskinned, so if you can traverse the source code, which is pretty well documented, and build upon their base viewer with your own, then it should be an easy task all-in-all.</p>

<p>You can also use pdfium instead of pdf.js, which is google’s SSR solution to pdf rendering on the web, but they have an experimental wasm build to look forward to and use for frontend programming.</p>

<h2 id="3-web-audio-api">3. Web Audio API</h2>

<p>There are a lot of underrated javascript APIs and libraries, especially when it comes to audio programming. Tone.js, and the Web Audio API can have you make your own suprisingly complicated and emulation-capable synthesizers for free.</p>

<p>You also have two other APIs that integrate well with them:</p>

<ul>
  <li>MIDI API - for all your MIDI integration needs (firefox has poor support for now)</li>
  <li>Mediastream Recording APIs - can do audio recording</li>
</ul>

<p>And plenty of more creative ways to integrate others.</p>

<p>These projects can also be ported to other languages rather easily. C++ has the VST SDK that audio programmers use to make professional synthesizers.</p>

<h3 id="modular-synth-environment">Modular Synth Environment</h3>

<p>Modular synthesis involves many modular synth parts that come together to create highly variable synthesizers.</p>

<p>In this project, you’d basically create a platform for it to work. Use Tone.js to save many headaches.</p>

<h3 id="keyboard-bard">Keyboard Bard</h3>

<p>I’ve always wanted to see the keyboard as a musical instrument. Take inspiration from keyboard-only command apps like vi, and create a musical instrument that takes significant skill and complexity to operate.</p>

<p>Musicians are very haughty about the ability for computer keyboards to play music, with their fancy pressure-sensitive keyboards. Prove them wrong.</p>

<p>Personally, I wouldn’t try and simulate them and try to play to the strength of a computer keyboard. Various toggles, commands, modes, extra keys.</p>

<p>You can play music in stream. Each key doesn’t have to be assigned to a certain key, instead you can “toggle” the octave you want to play at. There should be a way to play at multiple octaves at the same time as well.</p>

<p>You should be able to do some chord fun. Macroing chords, would be really fun, automating certain progressions and intervals. You’d essentially be playing with a mixer and instrument all in one.</p>

<h2 id="4-political-apps">4. Political Apps</h2>

<h3 id="whats-my-government-doing">What’s my government doing?</h3>

<p>People are sorely ignorant about government processes, but at the same time want to know more about their government. Create a way they can access government bills, get updates on their submissions and passings. Get summaries on those bills because nobody can read those things.</p>

<p>You can expand to include electoral information. I’m Canadian, so you can represent parliament in graphics, see what MPs are doing, what they’ve done. What they’ve passed, and what they’re promoting.</p>

<p>People want an easy and factual way to check out their government without having to deal with mass media.</p>

<p>Government websites usually do this already, but they do it ugly, and there’s no mobile app.</p>

<p>The only downside is if it catches on and you get a bunch of people using your app to get information on the government, then a lot of groups become interested in you. I’d stick to pure apolitical representation of fact.</p>

<p>But eventually you’ll have to deal with things like the Trump election scandal, and choosing either to show or not show the success of a candidate becomes a political choice.</p>

<p>Even deciding how to summarize bills will be a political decision that can be scrutinized.</p>

<p>Good luck!</p>

<h2 id="5-artistic-projects">5. Artistic Projects</h2>

<h3 id="memoir-site">Memoir Site</h3>

<p>I want to create a curated list of memoirs and people of history. Much like wikipedia’s biographies, but including self-reports, quotes, etc. Basically collect as much information as you can on historical peoples.</p>

<p>One can imagine the privacy nightmare, so I’d stick with historical figures.</p>

<h2 id="6-literate-programming">6. Literate Programming</h2>

<p>The great Donald Knuth coined the term “literate programming” to denote a program which represents source code in a textual yet compiliable/interpretable manner. Basically imagine if your comp-sci textbook had executable code-blocks. A famous example of its implementation can be seen in Jupyter notebook and Mercury for python.</p>

<h3 id="my-requirements">My Requirements</h3>

<p>I’d love for the ability to create a pure frontend literate programming interface that is SSR and SPA/MPA independant. This is how it would work; the user simply creates a code block like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;pre id="blah" language="javascript" module="stuff.html#moduleName" ref="#specialfunction .listoffunctions"&gt;

do stuff

&lt;/pre&gt;

</code></pre></div></div>

<p>Which executes on trigger, I guess after the modules load. I’d use local storage to make execution quicker, so you have a quick-to-access copy of the code, rather than having to fetch it. And I’d download it asynchronously, immediately at the start of web load if you do.</p>

<p>It must be purely frontend. The Javascript interprets/compiles it, which there are plenty of libraries for (Brython, JS-Interpreter, etc.).</p>

<p>My at-most minimum here is that it’s able to execute with jekyll. Maybe instead of attributes, it would use meta imports. It’d be fun to create for my portfolio.</p>

<hr />

<h2 id="non-programming-ideas">Non-programming Ideas</h2>

<h3 id="worthwhile-assembly-guides-and-tutorials-that-include-information-on-low-level-architecture">Worthwhile assembly guides and tutorials that include information on low-level architecture.</h3>

<p>It’s hard to find a low-level systems tutorial that’s as rich as the textbook Computer Organization and Design by Patterson and Hennessey.</p>

<p>The only one I’ve found is nand2tetris, and while I enjoy it, it’s not up to the complexity and depth of HTML guides of real software, like those of the linux documentation project, or the many GNU manuals and reference texts, something I’d really enjoy for low-level systems.</p>

<p>There’s something nice about reading through something that has the capacity to explain everything about what you learn. The fact that x86 doesn’t have something like that online is annoying to me.</p>

<p>Many of the usual problems with learning assembly is that they also disclude explanations on low-level architecture, jumping straight into assembly.</p>

<p>It’s a fair assumption to make, but I’d wager a lot of the people who want to learn assembly are higher level programmers who know little about low-level systems.</p>

<p>They can learn about low-level systems seperately, but there’s no better way to interface with instruction architecture than by using assembly.</p>

<h4 id="building-the-guide-or-any">Building the Guide (or any)</h4>

<p>You don’t need to know much about assembly or low-level systems architecture (hear me out), you’ll learn it as you develop the guide. You’ll only have to heavily rely on good sources, and be wise about the information you choose so you don’t propagate misinformation.</p>

<p>Those are skills that pertain to journalism, not whatever it is you’re teaching. And teachers who know a whole lot do not necessarily teach better.</p>

<p>You just have to understand what you’re teaching. <strong>Don’t</strong> write about <em>anything</em> you don’t come to understand or comprehend. Neither come to any premature conclusions.</p>

<p>Coming at it from a blank slate will help you see it from a student’s perspective. As you create it, write down questions you have of what confused you learning something, and what illuminated you, and use that in your guide.</p>

<p>As you go further into it, you can always come back and improve upon earlier sections with more accurate and useful info. Accept feedback but never reply to it. Don’t make it edutainment, because edutainment loves to talk about things they don’t understand or comprehend. Make it a serious and deep exploration of the topic you teach, doing deep research into the area.</p>

<p>Basically, you’re tutoring as you learn.</p>

<p>The beauty of HTML based guides is that they’re destructured and refactorable by nature. You can explain a thing in many different ways, and link them together. Come back later, update it, etc. It’s never static.</p>

<p>A few notes:</p>

<p><strong>Diagrams:</strong> Humans like imagining things visually. The art of making beautiful diagrams to represent what you teach is essential to creating a good guide.</p>

<p><strong>Writing Style:</strong> Ungendered, polite. If you want to go all out, you can use style guides.</p>

<p><strong>Accessible:</strong> Other people will want to read your stuff too, so if you include things like abbreviation tags, make sure you add labels and what not. You’ll have to go through the trouble of figuring out how accessibility works. If you want to go all out, you can check up on WCAG2.0 and MDN has a lot of good stuff on accessibility as well, but unless you’re a company or organization, it’s not a hard requirement.</p>

<p><strong>Draft then edit:</strong> Never edit prematurely like you wouldn’t optimize prematurely. Put a note somewhere as you write through of any changes you want to make, and come back to it when you edit it later.</p>]]></content><author><name>Ayub Elwhishi</name><email>alloycipher@gmail.com</email></author><summary type="html"><![CDATA[A list of personal project ideas that come to me, and that I wish I could do but don't have the time to do.]]></summary></entry><entry><title type="html">To Reign a Computer (WIP)</title><link href="http://localhost:4000/to-reign/" rel="alternate" type="text/html" title="To Reign a Computer (WIP)" /><published>2022-10-17T00:00:00-04:00</published><updated>2022-10-17T00:00:00-04:00</updated><id>http://localhost:4000/to-reign</id><content type="html" xml:base="http://localhost:4000/to-reign/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>I lack a definitive analysis on how to really become a good programmer so I can continuously improve rather than stagnate. This is not a list of what I know, and it’s not a list of what I will know. It’s more a list of what I want to learn personally.</p>

<p>DISCLAIMER: This is for me for what I wish to focus on and master, although I don’t mind people being inspired by it. I encourage you to master what you wish to master, for what you want to do.</p>

<p>DISCLAIMER 2: Heavy perspective shifting, be warned.</p>

<h2 id="breakdown-of-tools">Breakdown of Tools</h2>

<p>First comes the tools. It’s inspired from a few armchair thoughts I had on the epistemology of tools and theory.</p>

<ul>
  <li>Programming Language
    <ul>
      <li>Design paradigm</li>
      <li>Compiler -   Interpreter -	Specifications</li>
      <li>Testing library/framework</li>
    </ul>
  </li>
  <li>Text Editor
    <ul>
      <li>Traversal
        <ul>
          <li>Search (regex)</li>
          <li>Syntax Traversal</li>
        </ul>
      </li>
      <li>Macros</li>
      <li>Manipulation</li>
    </ul>
  </li>
  <li>Shell</li>
  <li>Software Design</li>
  <li>Debuggers</li>
  <li>Networking Tools</li>
  <li>Operating System</li>
  <li>File Editor</li>
  <li>Formatter</li>
  <li>CPU Instruction Set - Learning assembly and low-level programming is not fun, but it’s necessary and can be more useful than people realize. You’re most likely never going to write a program in machine code and assembly, but you’re going to write a lot of programs that turn into machine code and assembly.</li>
  <li>Design Tools</li>
  <li>Search Engine or Problem Repository (google/stack overflow)</li>
  <li>Cryptography Manager</li>
  <li>Password Manager</li>
  <li>Database Management System</li>
</ul>

<h2 id="breakdown-of-skills--wisdom">Breakdown of Skills / Wisdom</h2>

<h3 id="introduction-1">Introduction</h3>

<p>There are a few resources out there for the fabled “10x developer” that I’ll utilize here. I disenjoy the phrase, because it’s dumb, but it does help that intermediate programmers use “10x developer” as an industry keyword for going to the next level, which gets past all the beginner “how to become a better programmer” marketing spam that covers the internet.</p>

<p>For this list, we’re going to go with skills that aren’t tool dependant. For example it doesn’t matter what type of programming language you use, software design and architecture transcends.</p>

<ul>
  <li>Case Testing</li>
  <li>Performance Testing/Analysis
    <ul>
      <li>Big O</li>
    </ul>
  </li>
  <li>Debugging</li>
  <li>Error Handling (internal, as opposed to debugging which would be external)</li>
  <li>DS&amp;A</li>
  <li>Software Design &amp; Architecture</li>
  <li>Database Design</li>
  <li>Documentation Writing (focusing on documentation that aids the self)</li>
  <li>Cryptography</li>
</ul>

<!--Just as important as listing important skills, we want to list skills we shouldn't have.-->

<p>Next is theory, a lot of the stuff here precludes a basic understand of math.</p>

<ul>
  <li>Binary Mathematics</li>
  <li>Mathematical Logic
    <ul>
      <li>Formal Proofs</li>
    </ul>
  </li>
  <li>Discrete Mathematics</li>
  <li>Theory of Computation
    <ul>
      <li>Automota theory</li>
      <li>Formal Language Theory</li>
      <li>Computability Theory</li>
      <li>Computational Complexity Theory</li>
    </ul>
  </li>
  <li>Soft Computing
    <ul>
      <li>Neural Networks</li>
      <li>Fuzzy Logic</li>
      <li>Evolutionary Computation</li>
    </ul>
  </li>
</ul>

<h4 id="ideal-process">Ideal Process</h4>

<p>I should note here the process of programming itself is a meta-skill. You’ll see various processes, like the waterfall method, Agile, etc.</p>

<h3 id="case-testing">Case Testing</h3>

<p><a href="">expanded here</a></p>

<h3 id="performance-testing">Performance Testing</h3>

<h2 id="performance-thoughts">Performance Thoughts</h2>

<h3 id="choice--consistency">Choice &amp; Consistency</h3>

<p>While learning tools is good, there is a risk that tools and languages become obsolete. The ideal situation is that the tools become obsolete when I’m part of the development towards new tools.</p>

<p>Another ideal situation is that a tool remains significantly relevant, and will almost certainly continue to remain relevant. Nothing is going to replace Linux anytime soon.</p>

<p>What I don’t want is to have to learn something new every time, frequently, such that I do not retain memory and understanding. The danger to this ironically doesn’t come from obsoletism, but prematurely moving on to something else, not allowing what I just learned to settle and entrench.</p>

<p>This means I’ve essentially learned little to nothing. I believe I’ve learned how to use C pointers 4 times seperately, before it stuck.</p>

<p>It doesn’t mean I didn’t learn anything, concepts can remain, but it becomes of very little use.</p>

<p>That’s why consistency in what you learn matters. If you’re going to learn how to improve your Vim workflow, then you’re going to have to dedicate time to learning and applying it. Applying it frequently so you remember and are able to use it quickly and more efficientally for its use-case.</p>

<p>One way is to place restrictions so you don’t revert to what you already safely know.</p>

<h2 id="choice-of-tools">Choice of Tools</h2>

<h3 id="easy-choices">Easy Choices</h3>

<h4 id="operating-system">Operating System</h4>

<p>Linux is the OS of choice, of course.</p>

<p><strong>Distro</strong></p>

<p>The real hard question is the distro. Just kidding, it’s Debian. Debian is the perfect mix between ease-of-use and minimalism. Universal, and infrastructural, it’s not going to be obsolete for a while.</p>

<p>Stable, free, extremely safe, good documentation. I’ll use Debian.</p>

<h4 id="text-editor">Text Editor</h4>

<p>Text editors of choice are vim-tiny and neovim.</p>

<p>Vim-tiny is relevant because that’s the editor you’re always going to find in your fresh install after you remove emacs. It’s still powerful in its own right, and if you don’t have an internet connection it’s the only thing that’s sane to use.</p>

<p>Using it will also push you out of your comfort zone. It’s what you get when you write “vi” in a barebones linux install, although it’s a misnomer since it’s not the original vi.</p>

<p>The reason we use Neovim instead of Vim is because it provides more features and resources to make the most out of a text editor.</p>

<h3 id="instruction-set">Instruction Set</h3>

<p>For some reason this ended up being a hard decision. It should just be x86, but alas.</p>

<p>The three primary, non-obsolete instruction sets are x86, ARM, and RISC-V.</p>

<p>RISC-V was originally an educational aid, but it’s since developed into an alternative free and open source instruction set architecture. Due to its nature, it’s hard to find much hardware support for it. I’m going to have to emulate it using QEMU, unless I buy an implementation.</p>

<p>On the plus side, due to its educational nature, there are tons of ways to learn it. However, my aim is mastering, not just learning. I’d have to use RISC-V with purpose by its end. And while RISC-V SBCs do exist.</p>

<p>ARM, used by mobile devices, and Apple. ARM isn’t as secretive as Intel is, and likewise it’s the one that I’m going to interact with the most playing with single-board computers. I have a raspberry pi, it’s easy to learn it there so I don’t have to emulate it.</p>

<p>x86, mostly used by PCs, servers, and supercomputers. Most support, most use-cases, most proprietary.</p>

<p>And while I understand I shouldn’t fret so hard on these choices, I heard different instruction sets are complex. The x86 manual is 4834 pages, which I know matters on what I’m looking for, but it’s still ridiculously complicated. It requires a lot of investment.</p>

<p>For that reason I’m learning RISC-V. I like the idea of contributing to the RISC-V software environment, should I ever get the chance. I can always transfer my knowledge easier to x86/ARM after, and it’d be more thorough to play around with a CPU I can emulate rather than program on.</p>

<p>I don’t plan on going deep with ARM and x86 assembly anyways.</p>

<h3 id="language">Language</h3>

<p>Languages aren’t that important. Learning Javascript and C would match 99% of my use-cases. Automation and resources matters more than language in productivity.</p>

<p>Outside of what work requirements I have, the programming languages I want to master are:</p>

<h4 id="javascript--typescript">Javascript &amp; Typescript</h4>

<p>This will be my main scripting language. Machine learning, backend development, frontend development. Javascript (and by extension Typescript) is an extremely extensible language that fits a great majority of use-cases.</p>

<p>There’s multithreading and multiprocessing using workers, concurrency using asynchronous programming and promises.</p>

<p>There are always new and exciting technologies like bun.js that extend javascript. It’s the perfect ecosystem, with enough self-hatred to curb any form of evangelism present in other programming languages.</p>

<h4 id="cc">C/C++</h4>

<p>C/C++ are ubiquotous.</p>

<p>Plenty of the problems people have with them can be automated. C/C++ has package managers to make installing libraries less tedious. You can automate a bunch of things in vim, and you can use linters like any language to make C++ more clean. Tools like CMake and gdb are also their own powerhouse.</p>

<p>What matters when mastering a language like these two is its power, and both C and C++ have plenty of it.</p>

<p>C works really well with tools present in most default systems. Extremely flexible, well-supported, tooled. There’s little reason not to master C.</p>

<h4 id="functional-programming">Functional Programming?</h4>

<p>Functional programming isn’t included here, because these are languages that I want to master for productivity and possibility. I want to explore Lisp and Haskell, but there’d be no reason to master them.</p>

<h3 id="design">Design</h3>

<p>Design is one of those things that programmers love to skimp out on, but it proves an incredibly important skill that can make or break applications.</p>

<p>Apple didn’t get to where it was based on how open, versatile, and cheap their hardware is.</p>

<p>One thing to note is that there is a bunch of cookie-cutter designs going on right now, inspired by the apple minimalism trend that doesn’t seem to die. It’d be easy enough for anyone to use bootstrap, or any other UI/UX component library, but design is about character.</p>

<p>For product, I want to be pleasantly distinct from the rest. Not too similar that I’d blend in, but also not too different that I’d be ostracized for being weird.</p>

<p><a href="https://youtu.be/00rvUpLAhio">Image, people! Image!</a></p>

<p>For personal expression, it’s a sandbox, but design for marketing purposes is formulaic. This includes things like designing for my portfolio and what not.</p>

<p>Designing can be both fun, and horrifyingly painful. The trick is to know what I’m doing.</p>

<p>Here are my tools:</p>

<h4 id="markup-languages">Markup Languages</h4>

<p><strong>HTML &amp; SASS/SCSS (CSS)</strong></p>

<p>Basic for any web application programming. SASS/SCSS is a must. Pure CSS is good, but not good enough for complex applications, I want the modulability and flexibility of Sass to do things like theming and component handling.</p>

<h4 id="apps">Apps</h4>

<p><strong>Figma</strong></p>

<h2 id="list-of-things-to-learn">List of Things to Learn</h2>

<h3 id="non-programming-languages">Non-Programming Languages</h3>

<ul>
  <li>awk</li>
  <li>bash</li>
  <li>UML (unified modelling language) - this is to design large software projects</li>
  <li>GraphQL</li>
  <li>HTML/SCSS</li>
</ul>

<h3 id="command-line-tools--supporting-tools">Command Line Tools &amp; Supporting Tools</h3>

<ul>
  <li>sed - stream editor for filtering and transforming text</li>
  <li>git - version control software &amp; life-jacket</li>
  <li>strace - trace system calls and signals</li>
</ul>

<p><strong>Binary Utilities</strong> [^1] (for compiled programs)</p>

<ul>
  <li>ar - creates, modifies, extracts from archives which are mostly used as libraries</li>
  <li>nm - list symbols from object files</li>
  <li>objcopy - copy and translate object files</li>
  <li>objdump - display information from object files</li>
  <li>ranlib - generate index of archive contents</li>
  <li>readelf - display contents of elf format files</li>
  <li>size - list section sizes and total size</li>
  <li>strings - list printable strings from files</li>
</ul>

<p>Core Utilties [^2]</p>

<h3 id="language-1">Language</h3>

<ul>
  <li>javascript &amp; Typescript
    <ul>
      <li>nodejs -&gt; bunjs</li>
      <li>Web APIs</li>
    </ul>
  </li>
  <li>c/c++
    <ul>
      <li>conan - package manager for c/c++</li>
      <li>cscope - interactive examinination of c programs</li>
    </ul>
  </li>
  <li>RISC-V assembly
    <ul>
      <li>QEMU</li>
    </ul>
  </li>
</ul>

<h3 id="networking">Networking</h3>

<ul>
  <li>HTTP Protocol</li>
  <li>TCP/IP</li>
  <li>UDP</li>
</ul>

<h2 id="method">Method</h2>

<h3 id="definitions">Definitions</h3>

<h4 id="metatools">Metatools</h4>

<p>In the same way there’s metacognition, there are meta-tools. Tools that help you learn about other tools. They’re ideally the first things you want to be familiar with.</p>

<h3 id="linux">Linux</h3>

<p>Linux is going to be the system I spend to a fair bit of time in.</p>

<p>From the list previously, these are our meta-tools in the command-line:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">info</code></li>
  <li><code class="language-plaintext highlighter-rouge">man</code></li>
</ul>

<h4 id="manuals-and-tutorials">Manuals, and Tutorials</h4>

<p>First, this website: https://tldp.org</p>

<p>Bookmark it, and do all the tutorials and read all the manuals you want.</p>

<p>Here are the manuals I’ve found around the internet:</p>

<ul>
  <li>“The Linux User’s Guide”</li>
  <li>“The Linux System Administrator’s Guide”</li>
  <li>“Debian User’s Manual”</li>
  <li>“Debian Adminstrator’s Handbook”</li>
</ul>

<h2 id="industry-knowledge">Industry Knowledge</h2>

<p>Beyond the written is the unwritten. These are things that are said between people in industry, heard from the latest each other</p>

<hr />

<h2 id="bibliography">BIBLIOGRAPHY</h2>

<p>[^1] GNU Binary Utilities: https://ftp.gnu.org/old-gnu/Manuals/binutils-2.12/html_node/binutils.html#SEC_Top</p>

<p>[^2] GNU Coreutils: https://www.gnu.org/software/coreutils/manual/html_node/index.html</p>

<p>[^3] Measuring developer productivity in 2022 for data-driven decision makers: https://www.gitclear.com/measuring_developer_productivity_a_comprehensive_guide_for_the_data_driven</p>]]></content><author><name>Ayub Elwhishi</name><email>alloycipher@gmail.com</email></author><summary type="html"><![CDATA[A detailed exploration of mastering my computer. It's meant to be a personal map, but feel free to check it out.]]></summary></entry></feed>